#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Analyseur d'Optimisations MQL5
Analyse les r√©sultats d'optimisation MetaTrader 5 depuis des fichiers Excel XML
"""

import pandas as pd
import numpy as np
from collections import defaultdict
import xml.etree.ElementTree as ET
from typing import Dict, List, Tuple
import os
import json

class MQL5OptimizationAnalyzer:
    def __init__(self):
        self.data = None
        self.filtered_data = None
        self.variable_stats = {}
        self.best_optimizations = []

    def load_excel_xml(self, file_path: str):
        """Charge les donn√©es depuis un fichier Excel XML"""
        try:
            # Tentative de lecture directe avec pandas
            self.data = pd.read_excel(file_path)
            print(f"‚úÖ Fichier charg√©: {len(self.data)} optimisations trouv√©es")
            print(f"üìä Colonnes disponibles: {list(self.data.columns)}")
            return True
        except Exception as e:
            print(f"‚ùå Erreur de chargement: {e}")
            return False

    def filter_profitable_optimizations(self, min_profit: float = 7000, max_drawdown: float = 7.0):
        """Filtre les optimisations selon les crit√®res de profit et drawdown"""
        if self.data is None:
            print("‚ùå Aucune donn√©e charg√©e")
            return

        # Recherche automatique des colonnes profit et drawdown
        profit_cols = [col for col in self.data.columns if 'profit' in col.lower() or 'gain' in col.lower() or 'r√©sultat' in col.lower()]
        dd_cols = [col for col in self.data.columns if 'drawdown' in col.lower() or 'dd' in col.lower() or 'perte' in col.lower()]

        if not profit_cols:
            print("‚ö†Ô∏è Colonne profit non trouv√©e. Colonnes disponibles:")
            print(list(self.data.columns))
            return

        profit_col = profit_cols[0]
        dd_col = dd_cols[0] if dd_cols else None

        print(f"üìà Utilisation colonne profit: {profit_col}")
        if dd_col:
            print(f"üìâ Utilisation colonne drawdown: {dd_col}")

        # Filtrage
        mask = self.data[profit_col] >= min_profit

        if dd_col:
            # Convertir les pourcentages n√©gatifs en positifs si n√©cessaire
            dd_values = abs(self.data[dd_col])
            mask = mask & (dd_values <= max_drawdown)

        self.filtered_data = self.data[mask].copy()

        print(f"‚úÖ {len(self.filtered_data)} optimisations filtr√©es (profit ‚â• {min_profit}‚Ç¨, DD ‚â§ {max_drawdown}%)")

    def analyze_variables(self):
        """Analyse les variables d'optimisation et calcule les statistiques"""
        if self.filtered_data is None or len(self.filtered_data) == 0:
            print("‚ùå Aucune donn√©e filtr√©e disponible")
            return

        # Recherche des colonnes de variables (exclut les colonnes de r√©sultats)
        result_keywords = ['profit', 'gain', 'drawdown', 'dd', 'trades', 'total', 'net', 'gross', 'balance', 'equity']
        variable_cols = []

        for col in self.filtered_data.columns:
            if not any(keyword in col.lower() for keyword in result_keywords):
                variable_cols.append(col)

        print(f"üîç Variables d√©tect√©es: {variable_cols}")

        # Trouve la colonne profit pour les calculs
        profit_cols = [col for col in self.filtered_data.columns if 'profit' in col.lower() or 'gain' in col.lower() or 'r√©sultat' in col.lower()]
        profit_col = profit_cols[0] if profit_cols else None

        if not profit_col:
            print("‚ùå Colonne profit non trouv√©e pour l'analyse")
            return

        # Analyse chaque variable
        for var_col in variable_cols:
            try:
                # Nettoie les donn√©es (enl√®ve les NaN, convertit en num√©rique si possible)
                clean_data = self.filtered_data[[var_col, profit_col]].dropna()

                if len(clean_data) == 0:
                    continue

                # Groupe par valeur de variable
                grouped = clean_data.groupby(var_col)[profit_col]

                self.variable_stats[var_col] = {
                    'occurrences': len(grouped),
                    'valeurs_uniques': clean_data[var_col].nunique(),
                    'profit_min': grouped.min().min(),
                    'profit_max': grouped.max().max(),
                    'profit_moyen': clean_data[profit_col].mean(),
                    'top_valeurs': []
                }

                # Top 5 des meilleures valeurs pour cette variable
                top_values = grouped.mean().nlargest(5)
                for value, avg_profit in top_values.items():
                    count = grouped.get_group(value).count()
                    self.variable_stats[var_col]['top_valeurs'].append({
                        'valeur': value,
                        'profit_moyen': avg_profit,
                        'occurrences': count,
                        'profit_total': grouped.get_group(value).sum()
                    })

            except Exception as e:
                print(f"‚ö†Ô∏è Erreur analyse variable {var_col}: {e}")

    def find_best_optimizations(self, top_n: int = 10):
        """Trouve les meilleures optimisations"""
        if self.filtered_data is None:
            print("‚ùå Aucune donn√©e filtr√©e disponible")
            return

        # Trouve la colonne profit
        profit_cols = [col for col in self.filtered_data.columns if 'profit' in col.lower() or 'gain' in col.lower() or 'r√©sultat' in col.lower()]
        profit_col = profit_cols[0] if profit_cols else None

        if not profit_col:
            print("‚ùå Colonne profit non trouv√©e")
            return

        # Trie par profit d√©croissant
        best = self.filtered_data.nlargest(top_n, profit_col)

        self.best_optimizations = []
        for idx, row in best.iterrows():
            opt = {'profit': row[profit_col]}

            # Ajoute toutes les variables
            for col in self.filtered_data.columns:
                if col != profit_col:
                    opt[col] = row[col]

            self.best_optimizations.append(opt)

    def generate_report(self, output_file: str = "rapport_optimisations_mql5.txt"):
        """G√©n√®re un rapport complet"""
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("=" * 80 + "\n")
            f.write("         RAPPORT D'ANALYSE DES OPTIMISATIONS MQL5\n")
            f.write("=" * 80 + "\n\n")

            # R√©sum√© g√©n√©ral
            f.write("üìä R√âSUM√â G√âN√âRAL\n")
            f.write("-" * 40 + "\n")
            if self.data is not None:
                f.write(f"‚Ä¢ Total optimisations: {len(self.data)}\n")
            if self.filtered_data is not None:
                f.write(f"‚Ä¢ Optimisations profitables (>7000‚Ç¨, <7% DD): {len(self.filtered_data)}\n")
                if len(self.data) > 0:
                    success_rate = (len(self.filtered_data) / len(self.data)) * 100
                    f.write(f"‚Ä¢ Taux de succ√®s: {success_rate:.1f}%\n")
            f.write("\n")

            # Analyse par variables
            f.write("üîç ANALYSE PAR VARIABLES\n")
            f.write("-" * 40 + "\n")
            for var_name, stats in self.variable_stats.items():
                f.write(f"\nüéØ {var_name}\n")
                f.write(f"   ‚Ä¢ Valeurs uniques test√©es: {stats['valeurs_uniques']}\n")
                f.write(f"   ‚Ä¢ Profit minimum: {stats['profit_min']:.2f}‚Ç¨\n")
                f.write(f"   ‚Ä¢ Profit maximum: {stats['profit_max']:.2f}‚Ç¨\n")
                f.write(f"   ‚Ä¢ Profit moyen: {stats['profit_moyen']:.2f}‚Ç¨\n")

                f.write(f"   ‚Ä¢ Top 5 valeurs:\n")
                for i, top_val in enumerate(stats['top_valeurs'], 1):
                    f.write(f"     {i}. {top_val['valeur']} ‚Üí {top_val['profit_moyen']:.2f}‚Ç¨ (√ó{top_val['occurrences']})\n")

            # Meilleures optimisations
            f.write(f"\nüèÜ TOP {len(self.best_optimizations)} MEILLEURES OPTIMISATIONS\n")
            f.write("-" * 40 + "\n")
            for i, opt in enumerate(self.best_optimizations, 1):
                f.write(f"\n#{i} - Profit: {opt['profit']:.2f}‚Ç¨\n")
                for key, value in opt.items():
                    if key != 'profit':
                        f.write(f"   {key}: {value}\n")

        print(f"üìÑ Rapport g√©n√©r√©: {output_file}")

    def save_json_data(self, output_file: str = "optimisations_data.json"):
        """Sauvegarde les donn√©es en JSON pour usage ult√©rieur"""
        data_export = {
            'variable_stats': self.variable_stats,
            'best_optimizations': self.best_optimizations,
            'summary': {
                'total_optimizations': len(self.data) if self.data is not None else 0,
                'profitable_optimizations': len(self.filtered_data) if self.filtered_data is not None else 0
            }
        }

        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(data_export, f, ensure_ascii=False, indent=2, default=str)

        print(f"üíæ Donn√©es sauvegard√©es: {output_file}")


def main():
    """Fonction principale d'exemple d'utilisation"""
    analyzer = MQL5OptimizationAnalyzer()

    # Instructions d'utilisation
    print("üöÄ ANALYSEUR D'OPTIMISATIONS MQL5")
    print("=" * 50)
    print("\nüìã UTILISATION:")
    print("1. Placez votre fichier Excel XML dans le m√™me dossier")
    print("2. Modifiez le nom du fichier ci-dessous")
    print("3. Ex√©cutez le script")
    print("\nüí° EXEMPLE:")

    # Exemple d'utilisation (√† adapter)
    fichier_excel = "optimizations.xlsx"  # ‚Üê CHANGEZ CE NOM

    if os.path.exists(fichier_excel):
        print(f"üìÅ Chargement de {fichier_excel}...")

        if analyzer.load_excel_xml(fichier_excel):
            print("üîÑ Filtrage des optimisations profitables...")
            analyzer.filter_profitable_optimizations(min_profit=7000, max_drawdown=7.0)

            print("üìä Analyse des variables...")
            analyzer.analyze_variables()

            print("üèÜ Recherche des meilleures optimisations...")
            analyzer.find_best_optimizations(top_n=10)

            print("üìÑ G√©n√©ration du rapport...")
            analyzer.generate_report()
            analyzer.save_json_data()

            print("\n‚úÖ ANALYSE TERMIN√âE!")
            print("üìñ Consultez 'rapport_optimisations_mql5.txt' pour les r√©sultats")
    else:
        print(f"‚ùå Fichier '{fichier_excel}' non trouv√©")
        print("üìÅ Fichiers Excel disponibles dans le dossier:")
        excel_files = [f for f in os.listdir('.') if f.endswith(('.xlsx', '.xls', '.xml'))]
        for f in excel_files:
            print(f"   ‚Ä¢ {f}")


if __name__ == "__main__":
    main()